# 目录
- [目录](#目录)
- [](#)
- [2024-5-4 ***version 0.3.0***](#2024-5-4-version-030)
  - [添加后定义语句](#添加后定义语句)
  - [调整 allocate](#调整-allocate)
- [2024-5-3 ***version 0.3.0***](#2024-5-3-version-030)
  - [关于信息提示的想法](#关于信息提示的想法)
  - [对`Parser`的`Expect`进行调整](#对parser的expect进行调整)
  - [对`Token`的一些调整](#对token的一些调整)
  - [对`Parser`的一些调整](#对parser的一些调整)
- [2024-5-2 ***version 0.3.0***](#2024-5-2-version-030)
  - [使用`C++20`新特性 三路比较(太空船)运算符](#使用c20新特性-三路比较太空船运算符)
  - [新增 `RBTSet` 模板](#新增-rbtset-模板)
  - [新增加 `Position` 类](#新增加-position-类)
  - [新增加`Info`类](#新增加info类)
  - [关于报错警告信息](#关于报错警告信息)
  - [结束符的调整](#结束符的调整)
- [2024-5-1 ***version 0.3.0***](#2024-5-1-version-030)
  - [关于(报错, 警告)信息存储问题](#关于报错-警告信息存储问题)
  - [关于断行符`Line Break (\)`](#关于断行符line-break-)
  - [内联展开问题](#内联展开问题)
  - [优化细节](#优化细节)
  - [编译问题](#编译问题)
- [2024-4-30 ***version 0.3.0***](#2024-4-30-version-030)
  - [静态常量存储问题](#静态常量存储问题)
  - [`ast`实现](#ast实现)
  - [`token`修改](#token修改)
- [2024-4-29 ***version 0.3.0***](#2024-4-29-version-030)
  - [对`token`的修改](#对token的修改)
  - [对`lexer`的修改和实现](#对lexer的修改和实现)
  - [对`ast`修改](#对ast修改)
- [2024-4-20 ***version 0.3.0***](#2024-4-20-version-030)
  - [优化细节](#优化细节-1)
  - [关于重写问题](#关于重写问题)
- [2024-4-19 ***version 0.3.0***](#2024-4-19-version-030)
  - [优化代码](#优化代码)
  - [调整`Lexer`的接口](#调整lexer的接口)
  - [打算重写`ast, parser, assembler`](#打算重写ast-parser-assembler)
- [截至 2024-4-15 ***version 0.2.1***](#截至-2024-4-15-version-021)
- [2024-4-7](#2024-4-7)
- [2024-4-6](#2024-4-6)
- [2024-4-5](#2024-4-5)
- [截至 2024-4-4](#截至-2024-4-4)
  - [词法分析器](#词法分析器)
  - [语法分析器](#语法分析器)
  - [图形界面](#图形界面)

<div STYLE="page-break-after: always;"></div>


#
注意一个逻辑, 先转value还是先判断是否可求值

# 2024-5-4 ***version 0.3.0***
## 添加后定义语句
## 调整 allocate


# 2024-5-3 ***version 0.3.0***
## 关于信息提示的想法
- 可以弄一个表存储所有种类的信息, 然后将等级(建议, 警告, 报错)设置为可修改的存储进配置文件
## 对`Parser`的`Expect`进行调整
- 将`ExpectPeekToken, ExpectPeekTokenNot`和并， 传入`bool`类型进行不同操作
- 将自动添加报错信息移除, 改为通过判断手动添加报错信息
## 对`Token`的一些调整
- 使用`operator*`来取出字面量, 简化代码
- 新增`sm_contents`存储配合`content`函数输出可变的一些类型, 如: 寄存器, 字符串, 数字等
## 对`Parser`的一些调整
- 由于换行符工作移动到了`Lexer`中, `Parser`的`firstToken, nextToken`进行了优化
- 将`firstToken`第一次约定放在第1位, 第0位随意, 会被丢弃


# 2024-5-2 ***version 0.3.0***
## 使用`C++20`新特性 三路比较(太空船)运算符
对于运算符的重载, 使用`C++20`的 三路比较(太空船):`<=>`, 很好用, 测试运行效率, 和手动实现的没有任何区别, 需要作为键的比如`Position, Info`, 都换成`<=>`了
## 新增 `RBTSet` 模板
这个类是`QMap`的单类型实现, `QMap`是红黑树的键值对; 虽然`std::set`也是红黑树且是单类型, 但是为了利用`Qt`的特性, 所以我用`RBTSet`内部维护了一个 `QMap<T, DummyValue>`
## 新增加 `Position` 类
- 可以用来存放`token`或`statement`的行号, 列号, 长度
- 可以做`QHash`或者`QMap`的键
- `Token`中的行号列号改用`Position`存储
## 新增加`Info`类
- 以`type + Position`为键, 内部维护一个串
- `InfoList`为`RBTSet<Info>`
- `Lexer, Parser`中的信息改用`InfoList`存储
## 关于报错警告信息
**思路调整:**\
- 之前决定信息以`token`为单位, 而不能以`statement`的原因是: 句子难以处理换行问题; 其实可以将问题分解在前后端配合解决
  - 前端: 当标记长度超过列尾的时候换行继续标记
  - 后端: 若出现跨行的信息提示, 计算行总长, 而不是单纯的末尾列号减去开始列号
- 已经全部转为使用 InfoList 进行存储, 相应的添加信息也已经更改
## 结束符的调整
- 之前行结束符由`parser`在读取`token`的时候, 如果行号改变手动添加`EOF`
- 现在改为: 由`lexer`在行结束后添加`EOL`
- 最后修正`EOF`的行号列号, 并且在`EOF`之前一定是一个`EOL`, 所以语句分析中除了`program`, 其他不用管`EOF`


# 2024-5-1 ***version 0.3.0***
## 关于(报错, 警告)信息存储问题
信息, 一定要以`token`为单位, 而不能以`statement`
## 关于断行符`Line Break (\)` 
- `token`新增识别
- `lexer`新增识别和检错
- `parser`暂不支持
## 内联展开问题
将简单返回的函数实现放在了头文件中, 通过内联展开优化效率
## 优化细节
- `Token::textToInt`, 其中转化由`toInt -> toUInt`
- `Parser::parse_well` 改用`parse_expression`的方式分析里面的语句
- `ast`中的各个`node`采用构造传参, 仅有读取接口的方式, 对`node`进行封装
- 将 `Identifier, IdentifierList`从`ast -> vm`
## 编译问题
- 之前定下编译两个阶段: 
  - 一阶段: 将指令汇编成二进制编码的`string`形式, 计算空间地址, 预备好符号表(标识符还未替换)
  - 二阶段: 整合二进制编码, 同时将标识符替换掉, 并生成各种文件
- 现在更改为:
  - 一阶段: 将指令汇编成二进制编码的`string`形式, 并存储各个指令的长度 (`JMP`除外)
  - 二阶段: 计算空间地址, 同时将标识符替换掉, 并整理出符号表, 整合二进制编码, 生成各种文件
- 标识符重定义判断由`parser`转交给由`lexer`


# 2024-4-30 ***version 0.3.0***
## 静态常量存储问题
- 调整存储静态常量存储:`QStringList -> QSet<QString>`
- 映射表使用`QHash`替代`QMap`提高查找效率
- 映射关系一对一放在`QHash`, 多对一放在 `QSet+QHash`
  - 又 舍弃上面方案, 全部用`QHash`, 效率更高, 逻辑也更简单, 不过上面方案模块划分更清晰
- 更改`Token`静态存储
  - `sm_mnemonics_A, sm_symbols_A` 合并入 `sm_typeNames`
  - `sm_mnemonics_B -> sm_mnemonics`
  - `sm_symbols_B -> sm_singleSymbols`; `sm_symbols_C -> sm_doubleSymbols`
## `ast`实现
- `parse_well`采用暴力匹配的方式实现
## `token`修改
- `tokenType -> type`, 同时改变了判断逻辑, 优化性能 
- 修改`Type`: 
  - 新增: `SEGMENT, ENDS, END`
  - `LABEL -> IDENTIFIER`
  - `DB DW DD DQ DT -> DEFINE`
    
    

# 2024-4-29 ***version 0.3.0***
## 对`token`的修改
- 新增`Type: PTR, SHORT, NEAR, FAR, WORD, DWORD`
- 增添了`endColumn`
- 修复了`textToInt`无法识别 非0开头十六进制数的问题
- 修复了对非数字字符`[a-fA-F]`的非法判断为非法数字问题问题
- 修复了整数0识别为浮点数的问题
## 对`lexer`的修改和实现
- 完成了对 '#'指令的分析
- 完成了对标签定义语句的分析
- 修复了`program`空`stmt`紧跟换行 会结束分析的问题
- 修复了`restore`空格计算错误问题
- 增添了`expectPeekTokenNot`
- 优化了`program`的实现
- 优化了`clear`(优化空间占用)
## 对`ast`修改
- 取消了`goError`和`isError`, 通过递归传递`error`感觉收益很低
-`Program`添加`haveError`


# 2024-4-20 ***version 0.3.0***
## 优化细节
- 优化了: 构造函数, 拷贝构造, 析构函数等 的写法, 使用`default`
## 关于重写问题
***注意: 编译阶段应该将尽可能多的工作交给 `assembler`, 但是`parser`应该完成必要且不留重复工作给 `assembler`***
- ast
  - 取消了`traversal`, 将`json`放到`ast/json.cpp`文件中统一管理
  - 暂时违背开闭等原则, 将频繁访问的变量使用`public`申明, 方便修改, `等node大类几乎设计成熟后再考虑封装`
  - 添加了类: `Identifier, IdentifierList`


# 2024-4-19 ***version 0.3.0***
## 优化代码
- 去掉了`Node`的枚举前缀`NODE_`, 因为: 类内意义不大, 类外 `Node::`
- 去掉了`Token`的枚举前缀`TOKEN_`, 因为: 类内意义不大, 类外`Token::`
- 静态的`tokenTypeName -> typeName`, 静态的要加前缀 `Token::`, 故前缀`token`意义不大
- 静态的`nodeTypeName -> typeName`, 静态的要加前缀`Node::`, 故前缀`node`意义不大
- `Token`内部
  - ` MATE_ -> MAKE_X`, `LOAD_ -> LOAD_X`
  - `EOF -> TOKEN_EOF`, 因为`EOF`是`stdio`的宏, 值调整为`-1`和c语言统一
  - 优化了`tokenType`的实现细节
  - 新增`Type: ILLEGAL_INTEGER, LINE_BREAK(\)`
## 调整`Lexer`的接口
- 重构了构造以及调用逻辑, 提高复用性和使用的灵活性
- 取消了`Lexer::setFileName`接口
- 添加`Lexer::scan`接口, 可以扫描文件 或是 提取好的文本
- 重构`scan`二次遍历的逻辑, 
- 优化`scan`的添加错误逻辑, 修复对一个词多次提示
- 优化`scan`的实现细节

## 打算重写`ast, parser, assembler`
- 难点
  - 汇编语言和高级语言有些区别, 汇编语言需要在语法分析阶段需要, 解析操作数是否合规, 但是这又涉及到汇编阶段要做的事情, 确定完操作数合规, 几乎等价于完成汇编;
  - 如果将这一步操作放在`assembler`中进行, 相当于对抽象语法树又进行了一次语法分析并求值
- 重新定位
  - 将`compile`分为两个阶段
    - 一阶段: 将指令汇编成二进制编码的`string`形式, 计算空间地址, 预备好符号表(标识符还未替换)
    - 二阶段: 整合二进制编码, 同时将标识符替换掉, 并生成各种文件
  - `parser`: 进行语法分析同时完成`compile`一阶段
    - 可以存在多个, 对多个文本解析
    - 生成抽象语法树`AST`
    - `AST`根节点`program`存储符号表`QMap`
  - `assembler`: 完成`compile`二阶段, 并与文件交流 (不抛出错误和警告, 所有错误警告由`parser`抛出)
    - 与`parser`不同,`assembler`应该仅存在一个, 编译时调用
    - 传入`AST`不是坏树则可以编译
    - 读取`program`中的格式, 生成符号表(文件)
    - 根据符号表生成二进制文件
  - *也就是说, 文本检测到`parser`终止, 编译要调用 `assembler`*


# 截至 2024-4-15 ***version 0.2.1***
- ui方面达到运行的最低标准, 但是仍有许多bug和空缺功能
- 底层实现: 能勉强看, 但是很烂
  - `parser::mov`指令, '#'指令等
  - `ast`相应的结点
  - `assembler`和`vm`在实现阶段发现了定位不清, 职能划分不明确诸多问题, 导致整体思路非常混乱, 先使用 取巧 的方式实现其功能
- 之后需要从头梳理思路, 重写`parser, ast, assembler, vm`


# 2024-4-7
- 使用JSON生成抽象语法树`AST`
- 解决优化value后除法取余运算卡死的`bug`
- 解决数字的前缀后缀识别冲突`bug`


# 2024-4-6
- 优化了'#'指令的识别以及报错和警告
- 增加了`ast::MultipleStatement`用来构造前缀指令结点
- 实现了`ast::Value`类 以便递归下降求值, 支持运算, 但仅需用到前两种:
  - `~x -x +x * / % + - << >> & ^ |`
  - `< <= > >= == !=`
  - `~= *= /= %= += -= <<= >>= &= ^= |= =`
- 对字符串增加了转义符的支持以及相关警告和报错


# 2024-4-5
- 完成了'#'指令的识别
- 修改了前缀支持: `[-] -> [-+~]`
- 增添了对浮点数的识别以及不支持处理的报错
- 将`parser`对非法单词(`illegal`)的处理独立出来
- 修改了`ast`对`error`结点的遍历逻辑


# 截至 2024-4-4
## 词法分析器
-`token`和`lexer`几乎成熟, 目前支持识别:
  - '#'指令: 
    - `MAKE_BIN`
    - `MAKE_COM`
    - `MAKE_EXE`
    - `LOAD_SEGMENT=`
    - `LOAD_OFFSET=`
    - `REG=`
  - 单引号和双引号的字符串
  - 数字:
    - `16`进制前缀`0x...`
    - `2 8 10 16` 四种进制后缀`B O D H`
    - 前缀后缀不可共存
    - 通过二次扫描解决纯字符16进制数需要'0'开头, 但不确定后续是否会存在其他影响
  - 标签
  - 注释;
  - 符号: 
    - 运算: `~ * / % + - << >> & ^ | < <= > >= == != `
    - 其他: `= , : ? $ # ; () []`
  - 所有(应该)8086汇编指令助记符
  - 部分伪指令助记符
## 语法分析器
-`ast`和`parser`正在火速开发, 目前可以识别算术表达式
- 下一步: 
  - 1. 可以识别'#'指令
  - 2. 可以生成`mov`指令的抽象语法树
  - 3. 可以将`mov`指令汇编
  - 4. 可以将`mov`指令反汇编
  - 5. 完成虚拟机可以执行汇编指令
## 图形界面
- 文本编辑器
  - 语法高亮(所有词类已划分好)
  - 报错信息显示
  - 根据信息标记行和列范围
  - 实时监测是否有错误信息(设置定时器)
- 完成虚拟机测试的子窗口
